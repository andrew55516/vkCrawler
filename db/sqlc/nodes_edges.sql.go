// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: nodes_edges.sql

package db

import (
	"context"
	"time"
)

const createAllEdge = `-- name: CreateAllEdge :one
INSERT INTO all_edges (source, target, start)
VALUES ($1, $2, $3)
RETURNING id, source, target, start, "end"
`

type CreateAllEdgeParams struct {
	Source int64     `json:"source"`
	Target int64     `json:"target"`
	Start  time.Time `json:"start"`
}

func (q *Queries) CreateAllEdge(ctx context.Context, arg CreateAllEdgeParams) (AllEdge, error) {
	row := q.db.QueryRowContext(ctx, createAllEdge, arg.Source, arg.Target, arg.Start)
	var i AllEdge
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.Target,
		&i.Start,
		&i.End,
	)
	return i, err
}

const createAllNode = `-- name: CreateAllNode :one
INSERT INTO all_nodes (label, start)
VALUES ($1, $2)
RETURNING id, label, start, "end"
`

type CreateAllNodeParams struct {
	Label string    `json:"label"`
	Start time.Time `json:"start"`
}

func (q *Queries) CreateAllNode(ctx context.Context, arg CreateAllNodeParams) (AllNode, error) {
	row := q.db.QueryRowContext(ctx, createAllNode, arg.Label, arg.Start)
	var i AllNode
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Start,
		&i.End,
	)
	return i, err
}

const createCommentEdge = `-- name: CreateCommentEdge :one
INSERT INTO comments_edges (source, target, start)
VALUES ($1, $2, $3)
RETURNING id, source, target, start, "end"
`

type CreateCommentEdgeParams struct {
	Source int64     `json:"source"`
	Target int64     `json:"target"`
	Start  time.Time `json:"start"`
}

func (q *Queries) CreateCommentEdge(ctx context.Context, arg CreateCommentEdgeParams) (CommentsEdge, error) {
	row := q.db.QueryRowContext(ctx, createCommentEdge, arg.Source, arg.Target, arg.Start)
	var i CommentsEdge
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.Target,
		&i.Start,
		&i.End,
	)
	return i, err
}

const createCommentNode = `-- name: CreateCommentNode :one
INSERT INTO comments_nodes (label, start)
VALUES ($1, $2)
RETURNING id, label, start, "end"
`

type CreateCommentNodeParams struct {
	Label string    `json:"label"`
	Start time.Time `json:"start"`
}

func (q *Queries) CreateCommentNode(ctx context.Context, arg CreateCommentNodeParams) (CommentsNode, error) {
	row := q.db.QueryRowContext(ctx, createCommentNode, arg.Label, arg.Start)
	var i CommentsNode
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Start,
		&i.End,
	)
	return i, err
}

const createLikeEdge = `-- name: CreateLikeEdge :one
INSERT INTO likes_edges (source, target, start)
VALUES ($1, $2, $3)
RETURNING id, source, target, start, "end"
`

type CreateLikeEdgeParams struct {
	Source int64     `json:"source"`
	Target int64     `json:"target"`
	Start  time.Time `json:"start"`
}

func (q *Queries) CreateLikeEdge(ctx context.Context, arg CreateLikeEdgeParams) (LikesEdge, error) {
	row := q.db.QueryRowContext(ctx, createLikeEdge, arg.Source, arg.Target, arg.Start)
	var i LikesEdge
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.Target,
		&i.Start,
		&i.End,
	)
	return i, err
}

const createLikeNode = `-- name: CreateLikeNode :one
INSERT INTO likes_nodes (label, start)
VALUES ($1, $2)
RETURNING id, label, start, "end"
`

type CreateLikeNodeParams struct {
	Label string    `json:"label"`
	Start time.Time `json:"start"`
}

func (q *Queries) CreateLikeNode(ctx context.Context, arg CreateLikeNodeParams) (LikesNode, error) {
	row := q.db.QueryRowContext(ctx, createLikeNode, arg.Label, arg.Start)
	var i LikesNode
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Start,
		&i.End,
	)
	return i, err
}

const fillAllEdges = `-- name: FillAllEdges :exec
INSERT INTO all_edges (source, target, start)
select source, target, u.start
from (select t.id as source, s.id as target, start_time as start
      from all_nodes s
               join (select l.owner as like_owner, p.created_at as start_time, p.owner as post_owner
                     from likes l
                              join posts p on l.post_id = p.id) l on post_owner = s.label
               join all_nodes t on t.label = like_owner
      union all
      select t.id as source, s.id as target, c.created_at as start
      from all_nodes s
               join comments c on s.label = c.thread_owner
               join all_nodes t on t.label = c.owner) as u
`

func (q *Queries) FillAllEdges(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, fillAllEdges)
	return err
}

const fillAllNodes = `-- name: FillAllNodes :exec
INSERT INTO all_nodes (label, start)
SELECT owner, min(created_at) as min_created
from (select owner, created_at
      from comments
      union
      select thread_owner as owner, created_at
      from comments
      union
      select owner, created_at
      from posts
      union
      select l.owner, p.created_at
      from likes l
               join posts p on l.post_id = p.id) as owners
group by owner
`

func (q *Queries) FillAllNodes(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, fillAllNodes)
	return err
}

const fillCommentsEdges = `-- name: FillCommentsEdges :exec
INSERT INTO comments_edges (source, target, start)
select source, target, u.start
from (select t.id as source, s.id as target, c.created_at as start
      from comments_nodes s
               join comments c on s.label = c.thread_owner
               join comments_nodes t on t.label = c.owner) as u
`

func (q *Queries) FillCommentsEdges(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, fillCommentsEdges)
	return err
}

const fillCommentsNodes = `-- name: FillCommentsNodes :exec
INSERT INTO comments_nodes (label, start)
SELECT owner, min(created_at) as min_created
from (select owner, created_at
      from comments
      union
      select thread_owner as owner, created_at
      from comments
      union
      select owner, created_at
      from posts) as owners
group by owner
`

func (q *Queries) FillCommentsNodes(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, fillCommentsNodes)
	return err
}

const fillLikesEdges = `-- name: FillLikesEdges :exec
INSERT INTO likes_edges (source, target, start)
select source, target, u.start
from (select t.id as source, s.id as target, start_time as start
      from likes_nodes s
               join (select l.owner as like_owner, p.created_at as start_time, p.owner as post_owner
                     from likes l
                              join posts p on l.post_id = p.id) l on post_owner = s.label
               join likes_nodes t on t.label = like_owner) as u
`

func (q *Queries) FillLikesEdges(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, fillLikesEdges)
	return err
}

const fillLikesNodes = `-- name: FillLikesNodes :exec
INSERT INTO likes_nodes (label, start)
SELECT owner, min(created_at) as min_created
from (select owner, created_at
      from posts
      union
      select l.owner, p.created_at
      from likes l
               join posts p on l.post_id = p.id) as owners
group by owner
`

func (q *Queries) FillLikesNodes(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, fillLikesNodes)
	return err
}

const fillWeightedAllEdges = `-- name: FillWeightedAllEdges :exec
insert into all_edges_weighted (source, target, start, weight)
Select source, target, min(start) as start, count(*) as weight
from all_edges
group by source, target
`

func (q *Queries) FillWeightedAllEdges(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, fillWeightedAllEdges)
	return err
}

const fillWeightedCommentsEdges = `-- name: FillWeightedCommentsEdges :exec
insert into comments_edges_weighted (source, target, start, weight)
Select source, target, min(start) as start, count(*) as weight
from comments_edges
group by source, target
`

func (q *Queries) FillWeightedCommentsEdges(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, fillWeightedCommentsEdges)
	return err
}

const fillWeightedLikesEdges = `-- name: FillWeightedLikesEdges :exec
insert into likes_edges_weighted (source, target, start, weight)
Select source, target, min(start) as start, count(*) as weight
from likes_edges
group by source, target
`

func (q *Queries) FillWeightedLikesEdges(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, fillWeightedLikesEdges)
	return err
}
